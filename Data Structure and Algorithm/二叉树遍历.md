```python3
class TreeNode():
    def __init__(self,value=None,left=None,right=None):
        self.val=value
        self.left=left
        self.right=right

def BST_insert(root,value):
    if root == None:
        root= TreeNode(value)
    else:
        if root.val>value:
            root.left= BST_insert(root.left,value)
        else:
            root.right= BST_insert(root.right,value)
    return root
# 中序遍历
# 递归法
def mid_order1(root,res_list):
    if not root:
        return
    else:
        mid_order(root.left,res_list)
        res_list.append(root.val)
        mid_order(root.right,res_list)
# 迭代法（使用栈）
def mid_order2(root,res_list):
    temp_stack=[]  # 存储栈
    while root or temp_stack:
        while root:
            temp_stack.append(root)
            root=root.left
        root=temp_stack.pop()
        res_list.append(root.val)
        root=root.right

# 先序遍历
# 递归法
def pre_order1(root,res_list):
    if not root:
        return
    res_list.append(root.val)
    pre_order1(root.left,res_list)
    pre_order1(root.right,res_list)
# 迭代法（使用栈）
def pre_order2(root,res_list):
    temp_stack = []  # 存储栈
    while root or temp_stack:
        while root:
            res_list.append(root.val)
            temp_stack.append(root)
            root=root.left
        root=temp_stack.pop()
        root=root.right



# 后序遍历
# 递归法
def rear_order1(root,res_list):
    if not root:
        return
    rear_order1(root.left, res_list)
    rear_order1(root.right, res_list)
    res_list.append(root.val)
#迭代法
def rear_order2(root,res_list):
    temp_stack = []  # 存储栈
    mid_stack=[]
    while root or temp_stack:
        while root and isinstance(root,TreeNode):
            temp_stack.append(root)
            root=root.left
        if temp_stack:
            root=temp_stack.pop()
        if isinstance(root,TreeNode):
            if not root.right:
                res_list.append(root.val)
                root = root.right
            else:
                temp_stack.append(root.val)
                root = root.right
        else:
            res_list.append(root)
            if not temp_stack:
                break

# 层序遍历
# 自定义队列
class Node():
    def __init__(self,data,next=None):
        self.data = data
        self.next=next
class myque():
    def __init__(self):
        self.left=None
        self.right=None
    def enque(self,value):
        nd = Node(value)
        if not self.left and not self.right:
            self.left=nd
            self.right=nd
        else:
            self.right.next=nd
            self.right=nd
    def deque(self):
        if not self.left:
            return
        else:
            r = self.left
            self.left=self.left.next
            if not self.left:
                self.right = None
            return r.data
def layer_order(root,res_list):
    temp_queue=myque()
    temp_queue.enque(root)
    while temp_queue:
        root=temp_queue.deque()
        print(root)
        # res_list.append(root.val)
        if root.left:
            temp_queue.enque(root.left)
        if root.right:
            temp_queue.enque(root.right)

r=None
input_list=[7,3,9,2,5,8,10,1,4,6]
for v in input_list:
    r=BST_insert(r,v)
res=[]
layer_order(r,res)
print(res)

# 层序遍历
# 自定义队列
class Node():
    def __init__(self,data,next=None):
        self.data = data
        self.next=next
class myque():
    def __init__(self):
        self.length=0
        self.left=None
        self.right=None
    def is_empty(self):
        return self.left==None  # 根据左侧节点判断队列是否为空
    def enque(self,value):
        self.length+=1
        nd = Node(value)
        if not self.left:
            self.left=nd
            self.right=nd
        else:
            self.right.next=nd
            self.right=nd
    def deque(self):
        if self.left:  # 根据左侧节点判断队列是否为空
            r = self.left
            self.left=self.left.next
            self.length-=1
            return r.data
        else:
            raise ValueError('empty queue!')
```
